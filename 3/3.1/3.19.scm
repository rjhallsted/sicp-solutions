(define (is-cycled? x)
    (define (found-yet? pair steps)
        (define (found-yet-inner pair steps left-to-check)
            (cond ((or (= 0 steps) (null? left-to-check)) #f)
                ((eq? pair left-to-check) #t)
                (else (found-yet-inner pair (- steps 1) (cdr left-to-check)))))
        (found-yet-inner pair steps x))
    (define (is-cycled-inner items steps-so-far)
        (cond ((null? items) #f)
            ((found-yet? items steps-so-far) #t)
            (else (is-cycled-inner (cdr items) (+ steps-so-far 1)))))
    (is-cycled-inner x 0))
    
(define (last-pair x)
    (if (null? (cdr x))
        x
        (last-pair (cdr x))))
(define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)

(define d '(a b c))
(display (is-cycled? d)) (newline)
(make-cycle d)
(display (is-cycled? d)) (newline)

(define e (cons 'x d))
(display (is-cycled? e)) (newline)