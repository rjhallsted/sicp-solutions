
(define (install-rational-package)
    ;; internal procedures
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
        (if (and (polynomial? n) (polynomial? d))
            (let ((g (gcd-terms n d)))
                (cons (div n g) (div d g)))
            (let ((g (gcd n d)))
                (cons (div n g) (div d g)))))
    (define (make-rat n d)
        (let ((func (if (and (polynomial? n) (polynomial? d))
                        gcd
                        gcd-terms)))
            (let ((g (func n d)))
                (cons (div n g) (div d g)))))
    (define (gcd a b)
        (if (= b 0)
            a
            (gcd b (remainder a b))))
    (define (gcd-terms a b) 
        (if (empty-termlist? b)
            a
            (gcd-terms b (remainder-terms a b))))
    (define (add-rat x y)
        (make-rat (add (mul (numer x) (denom y))
                        (mul (numer y) (denom x)))
                  (mul (denom x) (denom y))))
    (define (sub-rat x y)
        (make-rat (sub (mul (numer x) (denom y))
                        (mul (numer y) (denom x)))
                  (mul (denom x) (denom y))))
    (define (mul-rat x y)
        (make-rat (mul (numer x) (numer y))
                  (mul (denom x) (denom y))))
    (define (div-rat x y)
        (make-rat (mul (numer x) (denom y))
                  (mul (denom x) (numer y))))
    ;; interface to rest of the system
    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
        (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
        (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
        (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
        (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
        (lambda (n d) (tag (make-rat n d))))
    'done)
(define (make-rational n d)
    ((get 'make 'rational) n d))